name: Wellness Bot

on:
  schedule:
    - cron: "*/10 * * * *"
  workflow_dispatch:
  issue_comment:
    types: [created, edited]

permissions:
  contents: read
  issues: write

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Run wellness bot
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          BOT_ISSUE_NUMBER: "1"   
        with:
          script: |
            const slackWebhook = process.env.SLACK_WEBHOOK_URL;
            const botIssueNumber = Number(process.env.BOT_ISSUE_NUMBER);

            if (!slackWebhook) {
              core.setFailed("Missing secret SLACK_WEBHOOK_URL");
              return;
            }
            if (!botIssueNumber || Number.isNaN(botIssueNumber)) {
              core.setFailed("Invalid BOT_ISSUE_NUMBER");
              return;
            }

            function nowKST() {
              const s = new Intl.DateTimeFormat("sv-SE", {
                timeZone: "Asia/Seoul",
                year: "numeric", month: "2-digit", day: "2-digit",
                hour: "2-digit", minute: "2-digit", second: "2-digit",
                hour12: false
              }).format(new Date());
              return new Date(s.replace(" ", "T") + "+09:00");
            }

            function format12h(kstDate) {
              const hh = kstDate.getHours();
              const mm = String(kstDate.getMinutes()).padStart(2, "0");
              const ampm = hh < 12 ? "AM" : "PM";
              const h12 = ((hh + 11) % 12) + 1;
              return `${String(h12).padStart(2, "0")}:${mm} ${ampm}`;
            }

            const STATE_START = "<!-- BOT_STATE_START -->";
            const STATE_END   = "<!-- BOT_STATE_END -->";

            function defaultState() {
              return {
                enabled: true,
                sleepUntilEpochMs: 0
              };
            }

            function extractState(body) {
              const sIdx = body.indexOf(STATE_START);
              const eIdx = body.indexOf(STATE_END);
              if (sIdx === -1 || eIdx === -1 || eIdx <= sIdx) return null;

              const jsonText = body.slice(sIdx + STATE_START.length, eIdx).trim();
              if (!jsonText) return null;

              try {
                const obj = JSON.parse(jsonText);
                if (typeof obj.enabled !== "boolean") return null;
                if (typeof obj.sleepUntilEpochMs !== "number") return null;
                return obj;
              } catch (e) {
                return null;
              }
            }

            function upsertState(body, stateObj) {
              const block = `${STATE_START}\n${JSON.stringify(stateObj, null, 2)}\n${STATE_END}\n`;
              const sIdx = body.indexOf(STATE_START);
              const eIdx = body.indexOf(STATE_END);

              if (sIdx === -1 || eIdx === -1 || eIdx <= sIdx) {
                const sep = body.endsWith("\n") ? "" : "\n";
                return body + sep + "\n" + block;
              }
              return body.slice(0, sIdx) + block + body.slice(eIdx + STATE_END.length);
            }

            async function getBotIssue() {
              const { data } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: botIssueNumber
              });
              return data;
            }

            async function updateBotIssueBody(newBody) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: botIssueNumber,
                body: newBody
              });
            }

            async function postSlack(text) {
              const res = await fetch(slackWebhook, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ text })
              });
              if (!res.ok) {
                const t = await res.text().catch(() => "");
                throw new Error(`Slack webhook failed: ${res.status} ${t}`);
              }
            }

            function parseCommand(raw) {
              const body = (raw || "").trim();
              const lower = body.toLowerCase();

              // enable / disable
              if (lower === "enable" || lower === "on") return { kind: "enable" };
              if (lower === "disable" || lower === "off") return { kind: "disable" };

              const m = lower.match(/^sleep\s+(\d+)\s*([hm])$/);
              if (m) {
                const n = Number(m[1]);
                const unit = m[2];
                if (Number.isFinite(n) && n > 0) {
                  const ms = unit === "h" ? n * 3600_000 : n * 60_000;
                  return { kind: "sleep", ms };
                }
              }
              return null;
            }

            const kst = nowKST();
            const minutes = kst.getMinutes();

            const issue = await getBotIssue();
            const currentBody = issue.body || "";
            let state = extractState(currentBody) || defaultState();

            if (context.eventName === "issue_comment") {
              const commentBody = context.payload.comment?.body || "";
              const cmd = parseCommand(commentBody);

              if (!cmd) {
                core.info("No recognized command in comment. Supported: enable | disable | sleep 8h | sleep 30m");
                return;
              }

              if (cmd.kind === "enable") {
                state.enabled = true;
                state.sleepUntilEpochMs = 0;
              } else if (cmd.kind === "disable") {
                state.enabled = false;
                state.sleepUntilEpochMs = 0;
              } else if (cmd.kind === "sleep") {
                state.enabled = true; 
                state.sleepUntilEpochMs = Date.now() + cmd.ms;
              }

              const newBody = upsertState(currentBody, state);
              await updateBotIssueBody(newBody);

              const untilText = (state.sleepUntilEpochMs > Date.now())
                ? ` (sleep until ${new Date(state.sleepUntilEpochMs).toISOString()})`
                : "";

              await postSlack(`üçÄ change status : enabled=${state.enabled}, sleepUntilEpochMs=${state.sleepUntilEpochMs}${untilText}`);
              return;
            }


            const onTenMinuteBoundary = (minutes % 10 === 0);

            if (state.sleepUntilEpochMs > 0 && Date.now() >= state.sleepUntilEpochMs) {
              state.sleepUntilEpochMs = 0;
              const newBody = upsertState(currentBody, state);
              await updateBotIssueBody(newBody);
              await postSlack(`üçÄ unsleep : enabled=${state.enabled}`);
            }

            const sleeping = (state.sleepUntilEpochMs > Date.now());

            if (!state.enabled) {
              core.info("Disabled: skipping");
              return;
            }
            if (sleeping) {
              core.info("Sleeping: skipping");
              return;
            }
            if (!onTenMinuteBoundary) {
              core.info("Not on 10-minute boundary: skipping");
              return;
            }

            const msgTime = format12h(kst);
            await postSlack(`üçÄ ${msgTime}`);
